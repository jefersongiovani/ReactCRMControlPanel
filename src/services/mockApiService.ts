/**
 * Project Name: CRM Control Panel
 * Project Type: React TypeScript Control Panel Application
 * Intended Hosting Type: Static Hosting (Netlify, Vercel, AWS S3)
 * Author: J. Schneider - j.g@live.com
 *
 * Mock API Service for CRM Control Panel Testing
 *
 * This service simulates backend API responses for testing purposes.
 * It uses a local SQLite database to provide realistic data interactions.
 *
 * PRODUCTION NOTE: This entire file should be removed in production.
 * Replace all mock API calls with actual backend API endpoints.
 *
 * To switch to production API:
 * 1. Set REACT_APP_USE_MOCK_API=false in .env
 * 2. Configure REACT_APP_API_BASE_URL to your production API
 * 3. Remove this file and update apiClient.ts
 */

import {
  User,
  LoginCredentials,
  LoginResponse,
  PaginatedResponse,
  UserRole,
} from '@/types';

// Import types from userService since they're defined there
import {
  UserFilters,
  CreateUserRequest,
  UpdateUserRequest,
} from './userService';

// Simulate network delay for realistic testing
const MOCK_DELAY = 500; // milliseconds

/**
 * Utility function to simulate API delay
 */
const delay = (ms: number = MOCK_DELAY): Promise<void> =>
  new Promise(resolve => setTimeout(resolve, ms));

/**
 * Generate mock JWT token
 * PRODUCTION NOTE: Real JWT tokens should be generated by your backend
 */
const generateMockToken = (userId: string): string => {
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(
    JSON.stringify({
      sub: userId,
      iat: Date.now() / 1000,
      exp: Date.now() / 1000 + 60 * 60, // 1 hour
    })
  );
  const signature = btoa('mock-signature');
  return `${header}.${payload}.${signature}`;
};

/**
 * Mock user data for testing
 * PRODUCTION NOTE: This data comes from your actual database in production
 */
const mockUsers: User[] = [
  {
    id: 'admin-001',
    email: 'admin@example.com',
    firstName: 'Admin',
    lastName: 'User',
    role: UserRole.ADMIN,
    isActive: true,
    avatar: null,
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z',
  },
  {
    id: 'manager-001',
    email: 'manager@example.com',
    firstName: 'Manager',
    lastName: 'User',
    role: UserRole.MANAGER,
    isActive: true,
    avatar: null,
    createdAt: '2024-01-02T00:00:00Z',
    updatedAt: '2024-01-02T00:00:00Z',
  },
  {
    id: 'user-001',
    email: 'user@example.com',
    firstName: 'Regular',
    lastName: 'User',
    role: UserRole.USER,
    isActive: true,
    avatar: null,
    createdAt: '2024-01-03T00:00:00Z',
    updatedAt: '2024-01-03T00:00:00Z',
  },
  {
    id: 'user-002',
    email: 'john.doe@example.com',
    firstName: 'John',
    lastName: 'Doe',
    role: UserRole.USER,
    isActive: true,
    avatar: null,
    createdAt: '2024-01-04T00:00:00Z',
    updatedAt: '2024-01-04T00:00:00Z',
  },
  {
    id: 'user-003',
    email: 'jane.smith@example.com',
    firstName: 'Jane',
    lastName: 'Smith',
    role: UserRole.MANAGER,
    isActive: false,
    avatar: null,
    createdAt: '2024-01-05T00:00:00Z',
    updatedAt: '2024-01-05T00:00:00Z',
  },
];

// Store current session for mock authentication
let currentSession: { user: User; token: string } | null = null;

/**
 * Mock Authentication Service
 * PRODUCTION NOTE: Replace with actual authentication API calls
 */
export const mockAuthService = {
  /**
   * Mock login endpoint
   */
  async login(credentials: LoginCredentials): Promise<LoginResponse> {
    await delay();

    // Simulate authentication check
    const user = mockUsers.find(u => u.email === credentials.email);

    if (!user) {
      throw new Error('Invalid email or password');
    }

    // In production, verify password hash
    if (credentials.password !== 'password123') {
      throw new Error('Invalid email or password');
    }

    if (!user.isActive) {
      throw new Error('Account is disabled');
    }

    const token = generateMockToken(user.id);
    const refreshToken = generateMockToken(user.id + '_refresh');

    currentSession = { user, token };

    return {
      token,
      refreshToken,
      user,
    };
  },

  /**
   * Mock token refresh endpoint
   */
  async refreshToken(
    _refreshToken: string
  ): Promise<{ token: string; refreshToken: string }> {
    await delay();

    if (!currentSession) {
      throw new Error('No active session');
    }

    const newToken = generateMockToken(currentSession.user.id);
    const newRefreshToken = generateMockToken(
      currentSession.user.id + '_refresh'
    );

    currentSession.token = newToken;

    return {
      token: newToken,
      refreshToken: newRefreshToken,
    };
  },

  /**
   * Mock get current user endpoint
   */
  async getCurrentUser(): Promise<User> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    return currentSession.user;
  },

  /**
   * Mock logout endpoint
   */
  async logout(): Promise<void> {
    await delay();
    currentSession = null;
  },
};

/**
 * Mock User Management Service
 * PRODUCTION NOTE: Replace with actual user management API calls
 */
export const mockUserService = {
  /**
   * Mock get users with pagination and filtering
   */
  async getUsers(filters: UserFilters = {}): Promise<PaginatedResponse<User>> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    let filteredUsers = [...mockUsers];

    // Apply search filter
    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      filteredUsers = filteredUsers.filter(
        user =>
          user.firstName.toLowerCase().includes(searchLower) ||
          user.lastName.toLowerCase().includes(searchLower) ||
          user.email.toLowerCase().includes(searchLower)
      );
    }

    // Apply role filter
    if (filters.role) {
      filteredUsers = filteredUsers.filter(user => user.role === filters.role);
    }

    // Apply active status filter
    if (filters.isActive !== undefined) {
      filteredUsers = filteredUsers.filter(
        user => user.isActive === filters.isActive
      );
    }

    // Apply sorting
    if (filters.sortBy) {
      filteredUsers.sort((a, b) => {
        const aValue = (a as any)[filters.sortBy!];
        const bValue = (b as any)[filters.sortBy!];

        if (filters.sortOrder === 'desc') {
          return bValue > aValue ? 1 : -1;
        }
        return aValue > bValue ? 1 : -1;
      });
    }

    // Apply pagination
    const page = filters.page || 0;
    const limit = filters.limit || 10;
    const startIndex = page * limit;
    const endIndex = startIndex + limit;
    const paginatedUsers = filteredUsers.slice(startIndex, endIndex);

    return {
      data: paginatedUsers,
      pagination: {
        page,
        limit,
        total: filteredUsers.length,
        totalPages: Math.ceil(filteredUsers.length / limit),
      },
    };
  },

  /**
   * Mock create user endpoint
   */
  async createUser(userData: CreateUserRequest): Promise<User> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    // Check if email already exists
    if (mockUsers.some(user => user.email === userData.email)) {
      throw new Error('Email already exists');
    }

    const newUser: User = {
      id: `user-${Date.now()}`,
      email: userData.email,
      firstName: userData.firstName,
      lastName: userData.lastName,
      role: userData.role as UserRole,
      isActive: userData.isActive ?? true,
      avatar: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    mockUsers.push(newUser);
    return newUser;
  },

  /**
   * Mock update user endpoint
   */
  async updateUser(id: string, userData: UpdateUserRequest): Promise<User> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    const userIndex = mockUsers.findIndex(user => user.id === id);
    if (userIndex === -1) {
      throw new Error('User not found');
    }

    // Check if email already exists (excluding current user)
    if (
      userData.email &&
      mockUsers.some(user => user.email === userData.email && user.id !== id)
    ) {
      throw new Error('Email already exists');
    }

    const updatedUser: User = {
      ...mockUsers[userIndex],
      ...userData,
      role: userData.role
        ? (userData.role as UserRole)
        : mockUsers[userIndex].role,
      updatedAt: new Date().toISOString(),
    };

    mockUsers[userIndex] = updatedUser;
    return updatedUser;
  },

  /**
   * Mock delete user endpoint
   */
  async deleteUser(id: string): Promise<void> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    const userIndex = mockUsers.findIndex(user => user.id === id);
    if (userIndex === -1) {
      throw new Error('User not found');
    }

    mockUsers.splice(userIndex, 1);
  },

  /**
   * Mock bulk delete users endpoint
   */
  async bulkDeleteUsers(ids: string[]): Promise<void> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    ids.forEach(id => {
      const userIndex = mockUsers.findIndex(user => user.id === id);
      if (userIndex !== -1) {
        mockUsers.splice(userIndex, 1);
      }
    });
  },
};

/**
 * Mock File Service
 * PRODUCTION NOTE: Replace with actual file management API calls
 */
export const mockFileService = {
  /**
   * Mock file upload endpoint
   */
  async uploadFiles(files: File[]): Promise<any[]> {
    await delay(1000); // Longer delay for file upload simulation

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    return files.map(file => ({
      id: `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: file.name,
      size: file.size,
      mimeType: file.type,
      url: `/files/${file.name}`,
      createdAt: new Date().toISOString(),
    }));
  },
};

/**
 * Mock Reports Service
 * PRODUCTION NOTE: Replace with actual analytics API calls
 */
export const mockReportsService = {
  /**
   * Mock get dashboard metrics endpoint
   */
  async getMetrics(): Promise<any> {
    await delay();

    if (!currentSession) {
      throw new Error('Not authenticated');
    }

    return {
      totalUsers: 1234,
      monthlyRevenue: 45678,
      totalOrders: 892,
      conversionRate: 3.45,
      chartData: [
        { label: 'Jan', value: 65 },
        { label: 'Feb', value: 78 },
        { label: 'Mar', value: 52 },
        { label: 'Apr', value: 91 },
        { label: 'May', value: 87 },
        { label: 'Jun', value: 95 },
      ],
    };
  },
};

/**
 * Check if mock API is enabled
 * PRODUCTION NOTE: This should always return false in production
 */
export const isMockApiEnabled = (): boolean => {
  return process.env.REACT_APP_USE_MOCK_API === 'true';
};
